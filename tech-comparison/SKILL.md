---
name: tech-comparison
version: 1.0.0
description: 根据用户输入的技术选项或项目需求进行多维度对比分析，输出结构化技术选型报告。适用场景：前端框架选型、后端技术对比、数据库选型、部署方案评估
---

# 技术选型对比助手

## 任务目标
- 本 Skill 用于：对比多个技术选项并提供建议，或根据项目需求推荐合适的技术方案
- 能力包含：智能识别技术类型、动态选择对比维度、生成结构化报告
- 触发条件：用户提及"对比"、"vs"、"选型"等关键词，或描述项目需求（如"我想开发跨平台应用"）

## 操作步骤

### 1. 理解需求
- **识别技术列表**：明确用户要对比的技术（1个、2个或多个）
- **单技术深度分析**：若用户仅提供单一技术（如"我想用SolidJS，它怎么样？"），则：
  - 分析其核心优势、典型场景、潜在局限
  - 推荐2-3个同类竞品供参考并简要说明差异
  - 仍按完整报告格式输出（表格可只有一列）
- **基于需求推荐**：若用户未明确列出技术，但描述了项目目标，先推荐2-4个主流候选技术并确认
- **技术类型识别**：
  - 识别技术类型（前端框架、后端语言/框架、数据库、部署方案等）
  - 若用户提供的技术**不属于同一类别**（如Java vs Docker），先澄清需求："您是想对比后端语言（如Java vs Go）还是部署方案（如Docker vs Podman）？"
  - **子生态归类规则**：若用户提到的技术属于子生态（如Next.js、Nuxt.js、Remix），请先归类到其主技术栈（React/Vue）下，并额外考虑SSR/SSG特有维度

### 2. 动态确定对比维度
根据技术类型智能选择适用维度，参考 [references/comparison-dimensions.md](references/comparison-dimensions.md)
- 前端框架：学习曲线、性能、生态、社区活跃度、TypeScript支持
- 后端框架：性能、开发效率、生态、学习曲线、适用场景
- 数据库：数据模型、性能、扩展性、一致性、适用场景
- 部署方案：性能、资源占用、打包体积、跨平台支持
- 通用维度：长期维护性、企业采用情况、学习曲线

### 3. 信息检索与分析
基于知识储备进行对比分析：
- **知识截止时间**：本报告基于截至**2024年底**的公开技术资料生成
- **数据优先级**：优先引用长期稳定来源（官方文档、GitHub仓库、MDN），谨慎引用年度调查（如State of JS 2023）并标注时效性
- **信息检索阶段**：
  1. 第一阶段：快速获取各技术概览，形成初步对比草稿
  2. 第二阶段：针对关键差异点进行深入分析，补充细节、基准数据或权威引用
- **数据来源**：官方文档、GitHub活跃度、npm trends、benchmark报告等
- 若信息不足或数据可能过时，明确标注"建议查询最新数据"

### 4. 生成结构化报告
按照 [references/output-template.md](references/output-template.md) 格式输出：
- **知识截止声明**：报告开头必须包含数据时效性说明
- 📊 **对比表格**：使用Markdown表格，固定列顺序，缺失值用"—"或"需配合其他工具"
- 📖 **分析与解释**：2-4段文字解释关键差异、背后原因、适用场景，避免过度承诺
- 💡 **建议与风险提示**：根据用户需求给出具体推荐，并列出潜在风险
- 📈 **可视化（可选）**：使用Mermaid绘制简单图表（生态对比、性能趋势）
- 🔗 **参考文献**：列出所有引用的来源（至少3个可靠来源），优先官方文档、GitHub、MDN

## 输出规范
- 语言：中文，专业但易懂
- 避免主观臆断，所有观点需有依据
- 若某技术不涉及某维度，标注"不适用"或"—"而非留空
- 表格固定列顺序，确保可读性
- 不声称"性能更快"，而说"在XX场景下基准测试显示更优"
- 标注数据时效性，建议用户验证最新信息

## 资源索引
- 维度库：见 [references/comparison-dimensions.md](references/comparison-dimensions.md)（按技术类型分类的对比维度及典型关键词）
- 输出模板：见 [references/output-template.md](references/output-template.md)（完整的报告格式模板及Mermaid图表示例）

## 注意事项
- 仅在需要时读取参考文档，保持上下文简洁
- 当信息不足时，明确说明"当前缺乏权威数据"，而非猜测
- 保持中立立场，客观呈现各技术的优缺点
- 标注知识截止时间（2024年底），建议用户验证最新信息
- 充分利用智能体的知识储备和分析能力，避免为简单任务编写脚本
- 处理模糊输入时，主动澄清用户真实需求
- 提供风险提示，帮助用户全面了解技术潜在问题

## 使用示例

### 示例1：前端框架对比
**用户输入**："帮我对比 React、Vue 和 Svelte，我想做一个高性能的单页应用"

**执行方式**：
1. 识别为前端框架对比
2. 动态选择维度：性能、学习曲线、生态、TypeScript支持、社区活跃度
3. 基于知识生成对比表格和分析
4. 根据用户"高性能单页应用"需求给出建议，并标注Svelte生态较小的风险

### 示例2：子生态归类
**用户输入**："Next.js 和 Nuxt.js 哪个更适合SEO？"

**执行方式**：
1. 识别为前端框架对比（SSR框架），归为主技术栈React vs Vue
2. 额外考虑SSR/SSG特有维度
3. 选择维度：SSR/SSG能力、SEO支持、生态、学习曲线
4. 生成对比表格和分析
5. 根据用户"SEO友好"需求明确推荐

### 示例3：单技术深度分析
**用户输入**："我想用SolidJS，它怎么样？"

**执行方式**：
1. 识别为单技术深度分析
2. 分析SolidJS的核心优势（细粒度响应式）、典型场景（高性能应用）、潜在局限（生态较小）
3. 推荐竞品：React（生态丰富）、Vue（学习曲线低）、Svelte（编译时优化）并简要说明差异
4. 生成报告（表格单列）

### 示例4：跨平台部署方案
**用户输入**："我打算开发一个跨平台桌面软件，Electron、Tauri 和 Neutralino 哪个更好？"

**执行方式**：
1. 识别为部署方案对比
2. 选择维度：性能、资源占用、打包体积、跨平台支持、生态
3. 生成对比表格和详细分析
4. 根据用户需求给出推荐，提示Electron资源占用较高的风险

### 示例5：后端框架对比
**用户输入**："单纯想了解 Python Web 框架：Django、Flask 和 FastAPI 有什么区别？"

**执行方式**：
1. 识别为后端框架对比
2. 选择维度：适用场景、开发效率、性能、学习曲线
3. 生成对比表格和分析
4. 提供通用选型建议

### 示例6：模糊输入处理
**用户输入**："对比 Java 和 Docker"

**执行方式**：
1. 识别到技术不属于同一类别（语言 vs 容器）
2. 澄清需求："您是想对比后端语言（如Java vs Go）还是部署方案（如Docker vs Podman）？"
3. 等待用户确认后继续分析
