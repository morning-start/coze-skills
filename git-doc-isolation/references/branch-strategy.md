# 分支策略详解

## 目录
- [策略概览](#策略概览)
- [孤立分支原理](#孤立分支原理)
- [安全机制分析](#安全机制分析)
- [工作流程对比](#工作流程对比)
- [适用场景](#适用场景)
- [风险评估](#风险评估)

## 策略概览

### 什么是文档隔离策略？
文档隔离策略是一种 Git 分支管理技术，通过创建与主干分支完全独立的孤立分支（orphan branch）来存储开发文档，确保文档永远不会进入主干分支的历史记录。

### 核心目标
1. **历史隔离**: docs/ 目录不出现在 main 分支的任何提交中
2. **防误操作**: 无法通过常规 merge 将文档合并到主干
3. **本地可用**: 开发分支可以临时获取文档用于参考
4. **安全清理**: 文档可以随时丢弃而不影响主干

### 策略组成
```
┌─────────────────────────────────────────────────────────┐
│                    文档隔离策略架构                      │
├─────────────────────────────────────────────────────────┤
│  主干层 (main)                                          │
│  ├── 生产代码                                           │
│  ├── 测试代码                                           │
│  └── 配置文件                                           │
│                                                         │
│  功能层 (feat-*)                                        │
│  ├── 从 main 创建                                       │
│  ├── 临时获取 docs/（只读）                              │
│  └── 合并回 main（不包含 docs）                          │
│                                                         │
│  文档层 (docs) ← 孤立分支                                │
│  ├── 开发文档                                           │
│  ├── API 文档                                           │
│  └── 设计文档                                           │
└─────────────────────────────────────────────────────────┘
```

## 孤立分支原理

### 什么是 Orphan Branch？
孤立分支（orphan branch）是一种特殊的 Git 分支，它没有父提交，与仓库中的其他分支没有共同的历史。

### 创建过程
```
正常分支创建:
main: A --- B --- C
                ↑
              feature (继承 C 的历史)

孤立分支创建:
main: A --- B --- C
                 
docs: D (全新的根提交，无父提交)
```

### 技术特性

| 特性 | 普通分支 | 孤立分支 |
|-----|---------|---------|
| 父提交 | 有 | 无 |
| 共同历史 | 与创建点共享 | 完全独立 |
| merge 行为 | 可自动合并 | 拒绝合并（无共同祖先） |
| 历史追溯 | 可追溯至初始提交 | 仅从该分支开始 |

### 为什么能防止误合并？

```bash
# 尝试合并孤立分支
git checkout main
git merge docs

# Git 的响应：
fatal: refusing to merge unrelated histories
```

Git 检测到两个分支没有共同祖先，因此拒绝自动合并。这是 Git 的安全机制，恰好符合我们的隔离需求。

## 安全机制分析

### 多层防护体系

```
┌────────────────────────────────────────────────────────┐
│ 第一层：分支隔离                                         │
│ ├── docs 是 orphan 分支，与 main 无共同历史               │
│ └── 无法通过 git merge 静默合并                          │
├────────────────────────────────────────────────────────┤
│ 第二层：本地排除                                         │
│ ├── .git/info/exclude 排除 docs/                        │
│ └── git add . 不会包含 docs/                            │
├────────────────────────────────────────────────────────┤
│ 第三层：提取方式                                         │
│ ├── 使用 git archive 提取（不保留 Git 信息）              │
│ └── 提取的文档是 untracked 状态                         │
├────────────────────────────────────────────────────────┤
│ 第四层：验证机制                                         │
│ ├── git log main -- docs/ 定期检查                      │
│ └── git merge-base main docs 验证独立性                  │
└────────────────────────────────────────────────────────┘
```

### 风险场景与防护

| 风险场景 | 防护措施 | 结果 |
|---------|---------|------|
| 误执行 `git add docs/` | `.git/info/exclude` 排除 | docs/ 不被跟踪 |
| 误执行 `git merge docs` | 无共同祖先，Git 拒绝 | 合并失败，提示错误 |
| 功能分支误提交 docs/ | 提取的文档是 untracked | 需要显式添加才会提交 |
| 强制合并 `--allow-unrelated` | 需要显式添加参数 | 操作显式，容易察觉 |

### 与 .gitignore 方案的对比

| 方案 | 机制 | 安全性 | 灵活性 |
|-----|------|-------|-------|
| **孤立分支** | 物理隔离 + 历史隔离 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| .gitignore | 路径排除 | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| git update-index --skip-worktree | 索引标记 | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| submodule | 子模块 | ⭐⭐⭐⭐ | ⭐⭐⭐ |

**孤立分支的优势**:
1. 文档历史完全独立，不污染主干
2. 无法通过常规操作意外合并
3. 文档可以独立版本管理
4. 本地临时使用不影响任何分支

## 工作流程对比

### 传统方案（有风险）

```
main: A --- B --- C --- D --- E
                ↑       ↑
              添加    删除
              docs/   docs/

问题：B 和 C 仍然包含 docs/ 的历史
     git log --all --full-history -- docs/ 
     会显示 B、C 的提交
```

### 孤立分支方案（安全）

```
main: A --- B --- C --- D --- E
                 
docs: X --- Y --- Z

优势：main 的历史完全不包含 docs/
     git log main -- docs/ 返回空
```

### 日常开发流程

```
1. 初始化阶段（一次）
   main ──────────────────────────
    ↓
   git checkout --orphan docs
   docs: [初始文档提交]
    ↓
   git checkout main

2. 开发阶段（每次功能）
   main: A ── B ── C
              ↑
            git checkout -b feat-xxx
   feat-xxx: 临时获取 docs/（只读）
    ↓
   开发完成，提交代码（不含 docs）
    ↓
   git checkout main
   git merge feat-xxx
   main: A ── B ── C ── D
    ↓
   清理：rm -rf docs/

3. 文档更新（独立进行）
   git checkout docs
   docs: [更新文档]
   git checkout main
```

## 适用场景

### 推荐使用场景

| 场景 | 说明 |
|-----|------|
| **AI 辅助开发** | 智能体需要参考文档但不应将文档修改提交到代码库 |
| **内部开发文档** | 包含敏感信息或临时性的开发指南 |
| **API 文档原型** | 频繁变更的 API 设计文档 |
| **设计稿/原型** | 大体积的设计资源文件 |
| **个人笔记** | 开发者的个人学习笔记 |

### 不适用场景

| 场景 | 原因 | 替代方案 |
|-----|------|---------|
| **项目官方文档** | 需要与代码版本同步 | 放在 main 分支的 docs/ |
| **用户手册** | 需要随版本发布 | 放在 main 分支 |
| **CHANGELOG** | 需要版本关联 | 放在 main 分支根目录 |
| **开源项目文档** | 需要公开可见 | 放在 main 分支或独立仓库 |

## 风险评估

### 潜在风险

| 风险 | 可能性 | 影响 | 缓解措施 |
|-----|-------|------|---------|
| 强制合并破坏隔离 | 低 | 高 | 团队规范 + 代码审查 |
| 文档分支丢失 | 中 | 中 | 定期备份 docs 分支 |
| 新成员误操作 | 中 | 中 | 完善的文档和培训 |
| 文档与代码不同步 | 中 | 低 | 定期更新 docs 分支 |

### 最佳实践建议

1. **团队规范**
   - 明确禁止 `--allow-unrelated-histories` 合并
   - 代码审查时检查是否包含 docs/ 目录
   - 新成员入职时进行 Git 工作流培训

2. **自动化检查**
   ```bash
   # 在 CI/CD 中添加检查
   if git log main -- docs/ | grep -q .; then
       echo "错误：main 分支包含 docs/ 历史"
       exit 1
   fi
   ```

3. **定期验证**
   ```bash
   # 每周/每月执行
   git log main -- docs/
   git merge-base main docs
   ```

4. **文档备份**
   ```bash
   # 定期推送 docs 分支到远程（可选）
   git push origin docs
   ```

## 总结

孤立分支策略提供了一种**物理隔离**级别的文档管理方式：

- ✅ 绝对安全：docs/ 永远不会进入 main 历史
- ✅ 防误操作：无法通过常规 merge 引入
- ✅ 灵活使用：本地临时获取，用完即删
- ✅ 独立管理：文档可以有自己的版本历史

这是目前最严格的 Git 文档隔离方案，特别适合需要确保主干分支绝对干净的场景。
