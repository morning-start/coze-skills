# 技能生命周期管理

## 目录
- [概述](#概述)
- [创建新技能](#创建新技能)
- [修改现有技能](#修改现有技能)
- [更新技能](#更新技能)
- [版本控制](#版本控制)
- [最佳实践](#最佳实践)

## 概述
技能生命周期管理涵盖技能从创建到演进的完整过程，包括创建、修改、更新和版本控制四个核心环节。

## 创建新技能

### 流程概览
```
需求分析 → 结构设计 → 编写文档 → 规范化检查
```

### 详细步骤

#### 步骤 1: 需求分析
1. **理解用户目标**
   - 明确技能要解决的核心问题
   - 识别目标用户群体
   - 确定使用场景和触发条件

2. **识别约束条件**
   - 技术约束（依赖、环境要求）
   - 功能边界（做什么、不做什么）
   - 性能要求（响应时间、资源限制）

3. **确定核心能力**
   - 列出技能必须具备的能力
   - 区分核心能力和可选能力
   - 识别能力间的依赖关系

#### 步骤 2: 结构设计
1. **确定技能名称**
   - 格式：小写字母 + 连字符
   - 要求：不以 `-skill` 结尾
   - 示例：✅ `data-cleaner` ❌ `data-cleaner-skill`

2. **编写技能描述**
   - 长度：100-150 字符
   - 格式：单行文本
   - 内容：包含核心价值与典型触发场景
   - 示例："数据清洗技能，支持缺失值处理、去重和格式标准化；当用户需要清洗原始数据时使用"

3. **定义能力列表（capabilities）**
   - 列出所有能力，使用简洁的动词+名词格式
   - 示例：`[数据清洗, 缺失值处理, 格式标准化, 数据验证]`

4. **设计操作步骤**
   - 标准流程：按顺序列出主要步骤
   - 可选分支：定义条件分支和异常处理
   - 每个步骤包含：输入、操作、输出

#### 步骤 3: 编写 SKILL.md
1. **YAML 前言区**
```yaml
---
name: <skill-name>
description: <技能描述>
dependency:          # 可选
  python:
    - package>=1.0.0
metadata:            # 可选
  capabilities: [能力列表]
  version: "1.0.0"
---
```

2. **Markdown 正文**
```markdown
# <技能标题>

## 任务目标
- 本 Skill 用于: <一句话场景>
- 能力包含: <核心能力要点>
- 触发条件: <典型用户表达或上下文信号>

## 操作步骤
- 标准流程:
  1. <步骤 1: 输入/准备>
  2. <步骤 2: 执行/处理>
  3. <步骤 3: 输出/校验>
- 可选分支:
  - 当 <条件 A>: 执行 <分支 A>
  - 当 <条件 B>: 执行 <分支 B>

## 资源索引
- 领域参考: 见 [references/<topic>.md](references/<topic>.md)(何时读取: <触发/场景>)

## 注意事项
- <重要注意事项 1>
- <重要注意事项 2>

## 使用示例
- <示例 1>
- <示例 2>
```

#### 步骤 4: 规范化检查
- [ ] 名称符合命名规范（小写字母+连字符，无 `-skill` 后缀）
- [ ] 描述为单行文本，长度 100-150 字符
- [ ] 包含任务目标、操作步骤章节
- [ ] 正文体量不超过 500 行
- [ ] 参考文档链接为一层引用
- [ ] 依赖声明格式正确（如有）

### 创建示例
**需求**: 创建一个数据清洗技能

**执行过程**:
1. **需求分析**: 用户需要清洗原始数据，处理缺失值、重复项和格式问题
2. **结构设计**:
   - 名称: `data-cleaner`
   - 描述: "数据清洗技能，支持缺失值处理、去重和格式标准化；当用户需要清洗原始数据时使用"
   - 能力: `[数据清洗, 缺失值处理, 去重, 格式标准化]`
3. **编写文档**: 生成完整的 SKILL.md
4. **规范化检查**: 通过所有检查项

## 修改现有技能

### 流程概览
```
读取分析 → 确定范围 → 执行修改 → 验证修改
```

### 详细步骤

#### 步骤 1: 读取并分析
1. **读取 SKILL.md**
   - 完整读取前言区和正文
   - 理解当前能力和流程
   - 识别设计意图和约束

2. **提取关键信息**
   - 当前能力列表（capabilities）
   - 操作步骤和流程
   - 依赖关系和资源引用
   - 版本历史和变更记录

3. **评估现状**
   - 识别需要改进的部分
   - 分析与其他技能的关系
   - 评估修改的影响范围

#### 步骤 2: 确定修改范围
1. **明确修改目标**
   - 列出需要修改的具体内容
   - 区分必要修改和可选优化
   - 确定修改的优先级

2. **评估影响范围**
   - 修改对现有能力的影响
   - 是否需要更新依赖的技能
   - 是否需要更新文档和示例

3. **制定修改计划**
   - 确定修改顺序
   - 识别需要同步更新的部分
   - 准备回退方案

#### 步骤 3: 执行修改
1. **修改目标内容**
   - 按照计划执行修改
   - 保持格式和风格一致性
   - 记录修改内容

2. **同步更新关联内容**
   - 更新相关的操作步骤
   - 更新资源索引
   - 更新使用示例

3. **检查一致性**
   - 确保前言区和正文一致
   - 确保能力和步骤对应
   - 确保示例与文档匹配

#### 步骤 4: 验证修改
- [ ] 修改后技能仍然可用
- [ ] 未引入新的问题或错误
- [ ] 文档完整性和准确性
- [ ] 格式和规范性符合标准

### 修改示例
**需求**: 修改 data-cleaner 技能，添加日志记录功能

**执行过程**:
1. **读取分析**: 理解当前清洗流程和能力
2. **确定范围**: 在每个主要步骤后添加日志记录
3. **执行修改**: 
   - 在操作步骤中添加日志记录说明
   - 更新 capabilities 添加 `日志记录`
   - 更新示例展示日志输出
4. **验证修改**: 检查流程完整性和文档一致性

## 更新技能

### 流程概览
```
评估更新需求 → 设计更新方案 → 执行更新
```

### 详细步骤

#### 步骤 1: 评估更新需求
1. **分析新需求**
   - 理解新增的功能或能力
   - 对比现有技能的能力差距
   - 识别是增量更新还是重构

2. **确定更新类型**
   - **增量更新**: 添加新能力，不改变现有能力
   - **功能调整**: 修改现有能力的实现方式
   - **重构**: 大规模结构调整，优化架构

3. **评估影响范围**
   - 对现有用户的影响
   - 对依赖技能的影响
   - 对文档和示例的影响

#### 步骤 2: 设计更新方案
1. **规划新增功能**
   - 详细设计新增能力的实现
   - 定义新增能力的接口
   - 规划集成方式

2. **识别调整部分**
   - 现有流程需要调整的地方
   - 资源引用需要更新的地方
   - 示例需要修改的地方

3. **制定过渡策略**
   - 如何平滑过渡到新版本
   - 是否保留旧功能兼容性
   - 迁移指南（如需要）

#### 步骤 3: 执行更新
1. **实现新增功能**
   - 在 capabilities 中添加新能力
   - 在操作步骤中添加新流程
   - 添加必要的资源引用

2. **调整现有内容**
   - 修改受影响的步骤
   - 更新资源索引
   - 调整示例代码

3. **更新文档**
   - 更新描述（如需要）
   - 更新注意事项
   - 添加变更说明

### 更新示例
**需求**: 给 data-cleaner 技能添加数据验证功能

**执行过程**:
1. **评估需求**: 新增能力，属于增量更新
2. **设计方案**: 
   - 新增 `数据验证` 能力
   - 在清洗流程后添加验证步骤
   - 定义验证规则和输出格式
3. **执行更新**:
   - 更新 capabilities: `[..., 数据验证]`
   - 添加验证步骤
   - 更新版本号为 1.1.0（minor 更新）

## 版本控制

### 版本号规则
采用语义化版本规范：**major.minor.patch**

- **major（主版本）**: 破坏性变更
  - 移除现有能力
  - 改变接口契约
  - 重大架构调整
  - 示例：1.2.3 → 2.0.0

- **minor（次版本）**: 新增功能
  - 添加新能力
  - 不破坏现有兼容性
  - 示例：1.2.3 → 1.3.0

- **patch（修订版本）**: 错误修复
  - Bug 修复
  - 文档更新
  - 示例：1.2.3 → 1.2.4

### 版本控制步骤

#### 步骤 1: 确定版本变更类型
1. **识别变更内容**
   - 新增了什么？
   - 修改了什么？
   - 移除了什么？

2. **评估影响**
   - 是否破坏现有功能？
   - 是否需要用户修改使用方式？
   - 是否影响依赖的技能？

3. **确定版本号**
   - 破坏性变更 → major +1
   - 新增功能 → minor +1
   - 修复更新 → patch +1

#### 步骤 2: 记录变更内容
1. **变更分类**
```
新增:
- 添加了数据验证能力
- 新增了 JSON 格式支持

修改:
- 优化了清洗算法
- 更新了示例代码

移除:
- 移除了旧版 API 支持（破坏性变更，需说明迁移方案）
```

2. **影响范围说明**
   - 哪些用户会受到影响
   - 需要采取什么行动
   - 迁移指南（如需要）

#### 步骤 3: 更新版本信息
1. **更新 metadata**
```yaml
metadata:
  version: "1.1.0"
  changelog:
    - "新增: 数据验证能力"
    - "新增: JSON 格式支持"
    - "优化: 清洗算法性能"
```

2. **更新文档**
   - 在 SKILL.md 中说明版本变更
   - 更新使用示例（如需要）
   - 添加迁移说明（如需要）

### 版本控制示例
**场景**: 给 data-cleaner 添加数据验证功能，并优化清洗算法

**执行过程**:
1. **确定类型**: 新增功能 + 优化，minor 版本更新
2. **记录变更**:
   - 新增：数据验证能力、JSON 格式支持
   - 修改：优化清洗算法
3. **更新版本**: 1.0.0 → 1.1.0
4. **更新文档**: 添加 changelog，更新描述

## 最佳实践

### 创建阶段
- **需求明确**: 在创建前充分理解需求和约束
- **单一职责**: 技能聚焦一个核心领域
- **接口先行**: 先设计输入输出接口，再实现功能
- **文档同步**: 编写文档的同时创建示例

### 修改阶段
- **小步快跑**: 每次修改聚焦一个明确目标
- **影响评估**: 修改前评估对现有功能的影响
- **全面验证**: 修改后验证所有相关功能
- **版本记录**: 重要修改更新版本和 changelog

### 更新阶段
- **向后兼容**: 尽量保持向后兼容
- **渐进演进**: 避免一次性大规模重构
- **用户告知**: 破坏性变更需提前告知用户
- **迁移支持**: 提供迁移指南和工具（如需要）

### 版本控制阶段
- **语义化版本**: 严格遵循语义化版本规范
- **详细记录**: 每个版本都有详细的变更记录
- **影响说明**: 明确说明变更对用户的影响
- **文档同步**: 版本更新同步更新所有文档

### 检查清单
- [ ] 需求分析充分，边界清晰
- [ ] 命名规范，描述准确
- [ ] 操作步骤清晰，可执行
- [ ] 文档完整，示例有效
- [ ] 版本控制规范，变更记录详细
- [ ] 修改影响评估到位
- [ ] 向后兼容性考虑（如适用）
