# 架构设计文档

## 系统概述
- **系统名称**：<系统名称>
- **架构类型**：<如：单体应用、分层架构等>
- **设计目标**：<设计目标概述>
- **文档版本**：v1.0.0
- **Python 版本要求**：3.11+
- **包管理工具**：UV
- **项目规模**：<小项目/大项目>

## 项目规模与组织方式

### 规模评估
- **项目规模**：<小项目/中型项目/大项目>
- **功能点数量**：<数量>
- **预期代码行数**：<行数>
- **复杂度评估**：<低/中/高>

### 组织方式选择

#### 小项目（< 5 个功能点）
```
project/
├── main.py                 # 主程序（所有代码）
├── pyproject.toml         # UV 配置
├── uv.lock                # 依赖锁定
├── README.md              # 项目说明（根目录）
└── docs/                  # 文档文件夹
    ├── requirements.md
    ├── architecture.md
    └── background.md
```

#### 大项目（> 5 个功能点）
```
project/
├── README.md              # 项目说明（根目录）
├── pyproject.toml         # UV 配置
├── uv.lock                # 依赖锁定
├── src/                   # 源代码
│   ├── __init__.py
│   ├── main.py           # 主入口
│   ├── api/              # API 模块
│   │   ├── __init__.py
│   │   └── routes.py
│   ├── models/           # 数据模型
│   │   ├── __init__.py
│   │   └── schemas.py
│   ├── services/         # 业务逻辑
│   │   ├── __init__.py
│   │   └── weather.py
│   └── utils/            # 工具函数
│       ├── __init__.py
│       └── helpers.py
├── tests/                 # 测试
│   ├── __init__.py
│   └── test_main.py
└── docs/                  # 文档
    ├── requirements.md
    ├── architecture.md
    └── background.md
```

### 当前选择
**本项目采用**：<小项目/大项目>架构

**选择理由**：<基于功能点数量、复杂度、未来扩展性>

---

## 版本控制策略
- **版本规范**：使用语义化版本（Semantic Versioning，vX.Y.Z）
  - X：主版本号（不兼容的 API 修改）
  - Y：次版本号（向下兼容的功能性新增）
  - Z：修订号（向下兼容的问题修正）
- **依赖版本锁定**：使用 UV 的 uv.lock 文件
  - 锁定所有依赖的精确版本
  - 确保环境可复现性
  - 自动生成，不可手动编辑
- **版本更新策略**：
  - 主版本更新：必须经过充分测试和审查
  - 次版本更新：向下兼容，可以使用 `uv lock --upgrade`
  - 修订版本更新：通常可以自动更新

---

## 技术选型
### 核心技术栈
- **编程语言**：Python 3.11+ - 选择理由：<性能、类型注解、现代语法特性>
- **框架/库**：<框架名称及版本> - 选择理由：<详细理由>
- **数据存储**：<存储方案> - 选择理由：<理由>
- **包管理**：UV - 选择理由：快速、可靠、现代化
- **其他工具**：<工具列表>

### 技术选型理由（详细对比）
#### 选型对比表
| 维度 | 方案A | 方案B | 最终选择 |
|------|-------|-------|----------|
| 性能 | <评估> | <评估> | <方案> |
| 学习曲线 | <简单/复杂> | <简单/复杂> | <方案> |
| 生态系统 | <丰富/有限> | <丰富/有限> | <方案> |
| 文档质量 | <评估> | <评估> | <方案> |
| 社区支持 | <活跃/一般> | <活跃/一般> | <方案> |
| Python 3.11+ 支持 | ✅/⚠️/❌ | ✅/⚠️/❌ | <方案> |
| 长期维护性 | <活跃/停滞> | <活跃/停滞> | <方案> |
| 类型注解支持 | <完整/部分/不支持> | <完整/部分/不支持> | <方案> |
| UV 兼容性 | ✅/⚠️/❌ | ✅/⚠️/❌ | <方案> |

#### 选型权衡分析
- **最终选择**：<方案名称>
- **选择理由**：
  1. <理由1，引用对比数据>
  2. <理由2，引用对比数据>
  3. <理由3，引用对比数据>
- **权衡说明**：
  - 性能 vs 易用性：选择 <方案> 是因为 <理由>
  - 功能 vs 复杂度：选择 <方案> 是因为 <理由>
  - 生态系统 vs 创新性：选择 <方案> 是因为 <理由>
- **已知不足**：<选择方案的局限性或不足>
- **不推荐场景**：<何种情况下不适用此方案>

### UV 依赖管理
#### pyproject.toml 配置
```toml
[project]
name = "project-name"
version = "1.0.0"
description = "项目描述"
requires-python = ">=3.11"
dependencies = [
    "requests>=2.31.0",
    "pydantic>=2.0.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0.0",
    "black>=23.0.0",
    "mypy>=1.0.0",
]

[tool.uv]
dev-dependencies = [
    "pytest>=7.0.0",
]
```

#### 依赖管理策略
- **核心依赖**：锁定版本，使用 `uv add package`
- **开发依赖**：使用 `uv add --dev package`
- **更新策略**：定期运行 `uv lock --upgrade`
- **兼容性检查**：使用 `uv check` 验证依赖兼容性

---

## 系统架构
### 模块划分
```
系统结构图或模块关系图
```

#### 模块1：<模块名称>
- **职责**：<模块功能描述>
- **接口**：
  - 函数/类名：`<函数名>(<参数>) -> <返回类型>`  # 必须包含类型注解
  - 描述：<功能说明>
  - Python 3.11+ 特性：<如有>

#### 模块2：<模块名称>
- **职责**：<模块功能描述>
- **接口**：
  - 函数/类名：`<函数名>(<参数>) -> <返回类型>`  # 必须包含类型注解
  - 描述：<功能说明>
  - Python 3.11+ 特性：<如有>

### 数据流设计
```
数据流图或流程描述
```

1. **输入处理**：<描述数据如何进入系统>
2. **处理流程**：<描述数据处理步骤>
3. **输出生成**：<描述结果如何输出>

---

## 接口定义
### 外部接口
- **API接口**：<如调用第三方API>
  - 端点：<URL>
  - 请求方式：<GET/POST/PUT/DELETE>
  - 参数：<参数列表>
  - 响应格式：<响应结构>

### 内部接口
#### 接口1
- **函数签名**：`def function_name(param1: type, param2: type) -> return_type:`
  - 必须使用 PEP 585 内置泛型类型（如 `list[int]` 而非 `List[int]`）
- **参数说明**：
  - `param1`：<描述>
  - `param2`：<描述>
- **返回值**：<描述>

---

## 技能识别和管理

### 可提取为技能的模块
识别项目中可复用的功能模块，将其定义为"技能"以便后续复用。

#### 技能列表
- **技能1**：`<函数/类名>` - `<功能描述>` - 位置：<文件路径>
- **技能2**：`<函数/类名>` - `<功能描述>` - 位置：<文件路径>
- **技能3**：`<函数/类名>` - `<功能描述>` - 位置：<文件路径>

### 技能接口定义
为每个可复用技能定义清晰的接口，包含类型注解。

#### 技能1：`<技能名称>`
- **功能**：<技能功能描述>
- **位置**：<文件路径>
- **函数签名**：
  ```python
  def skill_function(data: list[dict[str, Any]]) -> dict[str, Any]:
      """技能功能的实现"""
      pass
  ```
- **输入参数**：
  - `data`：<参数描述>
- **返回值**：<返回值描述>
- **依赖**：<依赖的其他技能或库>
- **复用场景**：<适用的复用场景>

#### 技能2：`<技能名称>`
- **功能**：<技能功能描述>
- **位置**：<文件路径>
- **函数签名**：
  ```python
  def skill_function(param1: str, param2: int) -> bool:
      """技能功能的实现"""
      pass
  ```
- **输入参数**：
  - `param1`：<参数描述>
  - `param2`：<参数描述>
- **返回值**：<返回值描述>
- **依赖**：<依赖的其他技能或库>
- **复用场景**：<适用的复用场景>

### 技能复用指南
说明如何在新功能实现中调用已有技能。

#### 调用方式
1. **直接调用**：
   ```python
   from src.utils.helpers import skill_function

   result = skill_function(data)
   ```

2. **组合调用**：
   ```python
   from src.utils.helpers import skill1, skill2

   result = skill2(skill1(data))
   ```

3. **适配器模式**：
   ```python
   def adapt_skill_for_new_feature(data: list[Any]) -> dict[str, Any]:
       """适配器函数，将新功能的输入转换为技能需要的格式"""
       adapted_data = transform_data(data)
       return existing_skill(adapted_data)
   ```

#### 复用原则
- 优先使用已有技能，避免重复开发
- 确保技能的接口稳定，避免频繁修改
- 技能应具有单一职责，功能清晰
- 技能应包含完整的类型注解和文档
