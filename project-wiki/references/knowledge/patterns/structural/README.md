# 结构型模式 (Structural Patterns)

结构型模式介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效。

## 模式列表

### 1. 适配器模式 (Adapter)
- **定义**：将一个类的接口转换成客户希望的另一个接口
- **关键点**：接口转换，使不兼容的类能一起工作
- **适用场景**：需要使用现有类，但其接口不符合需求
- [查看详细文档](./adapter.md)

### 2. 桥接模式 (Bridge)
- **定义**：将抽象部分与实现部分分离，使它们都可以独立变化
- **关键点**：分离两个独立变化的维度
- **适用场景**：需要在多个维度上扩展的类层次结构
- [查看详细文档](./bridge.md)

### 3. 组合模式 (Composite)
- **定义**：将对象组合成树形结构表示"部分-整体"的层次结构
- **关键点**：统一处理单个对象和组合对象
- **适用场景**：需要表示对象的部分-整体层次结构
- [查看详细文档](./composite.md)

### 4. 装饰模式 (Decorator)
- **定义**：动态地给对象添加额外的职责
- **关键点**：运行时扩展功能，比继承更灵活
- **适用场景**：需要在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责
- [查看详细文档](./decorator.md)

### 5. 外观模式 (Facade)
- **定义**：为子系统中的一组接口提供一个统一的接口
- **关键点**：简化复杂系统的访问
- **适用场景**：需要简化复杂子系统的使用
- [查看详细文档](./facade.md)

### 6. 享元模式 (Flyweight)
- **定义**：运用共享技术有效地支持大量细粒度的对象
- **关键点**：共享对象，减少内存使用
- **适用场景**：系统中有大量相似对象，需要节省内存
- [查看详细文档](./flyweight.md)

### 7. 代理模式 (Proxy)
- **定义**：为其他对象提供一种代理以控制对这个对象的访问
- **关键点**：控制访问，添加间接层
- **适用场景**：需要控制对对象的访问，或添加额外功能
- [查看详细文档](./proxy.md)

---

## 结构型模式对比

| 模式 | 主要目的 | 实现方式 | 特点 |
|------|---------|---------|------|
| 适配器模式 | 接口转换 | 对象适配/类适配 | 事后补救 |
| 桥接模式 | 分离抽象和实现 | 组合 | 预先设计 |
| 组合模式 | 树形结构 | 递归组合 | 整体-部分统一 |
| 装饰模式 | 动态添加功能 | 包装 | 功能叠加 |
| 外观模式 | 简化接口 | 高层封装 | 最少知道 |
| 享元模式 | 对象共享 | 工厂+缓存 | 内存优化 |
| 代理模式 | 控制访问 | 代理对象 | 访问控制 |

---

## 核心设计原则

- **合成复用原则**：优先使用组合，而非继承
- **迪米特法则**：最少知道原则，减少对象间耦合
- **单一职责原则**：一个类只负责一项职责
